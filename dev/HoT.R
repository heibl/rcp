#' Heads or Tails alignment reliability
#' @description Assess reliability in an aligment using the
#'   HoT algorithm
#' @param seq An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequences of DNA or amino acids.#' @param cutoff specifies a cutoff to remove unreliable columns below the cutoff
#' @param cutoff specifies a cutoff to remove unreliable columns below the
#'   cutoff
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty either \code{"mafft"} (default) or\code{"prank"}.
#' @param mafft_exec A character string giving the path to the executable of MAFFT
#'   (usually: '/usr/local/bin/mafft')
#' @param method further arguments passed to MAFFT, default is "auto"
#' @param mask specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA)
#'
#' @return alignment_reliability
#' @return residue_reliability
#' @return sequence_reliability
#' @return column_reliability
#' @return HoT_MSA: is the base MSA removed from unreliable columns below
#'   \coe{cutoff}
#' @return base_msa
#'
#' @details Calculates column reliability by comparing alternative
#'   MSAs generated by aligning guide tree partitions.
#' @author Franz-Sebastian Krah
#' @references G. Landan and D. Graur (2008). Local reliability measures from sets of co-optimal multiple sequence alignments. 13:15--24
#'
#' @importFrom ips mafft
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @author Franz-Sebastian Krah
#' @author Christoph Heibl


HoT <- function(seq, cutoff = 0.93, parallel = FALSE, ncore,
  msa.program = "mafft", method = "auto", mask = FALSE,
  mafft_exec){


  if (missing(mafft_exec)) mafft_exec <- "/usr/local/bin/mafft"

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(seq, "DNAbin") & !inherits(seq[[1]], "SeqFastaAA"))
    stop("sequences not of class DNAbin (ape) or SeqFastaAA (seqinr)")


  ##############################################
  ## PART I
  ##############################################
  ## BASE and alternative MSAs
  ##############################################
  # seq_nam <- names(seq)

  ## if AA Sequences perform data prep first
  # if(inherits(seq[[1]], "SeqFastaAA")){
  #   seq <- lapply(seq, as.character)
  #   seq <- rbind.fill(lapply(seq,
  #     function(y) { as.data.frame(t(y), stringsAsFactors=FALSE) }))
  #   seq <- as.AAbin(as.matrix(seq))
  # }

  ## Generate BASE MSA
  if (msa.program == "mafft"){
    # base.msa <- mafft_AA(seq, method = method)
    # C  On my MAC mafft is in /usr/local/bin/ but function is not working
    base.msa <- mafft(seq, method = method, exec = mafft_exec)
  }

  ## calculate start guide tree
  base.msa.ml <- as.phyDat(as.character(base.msa))
  # find ML distance as input to nj tree search
  ml.dist.msa <- dist.ml(base.msa.ml)
  # NJ
  start_tree <- ape::nj(ml.dist.msa)
  start_tree <- multi2di(start_tree)
  start_tree <- compute.brlen(start_tree)
  plot(start_tree)

  ## produce MSA partitions
  align_parts <- partitions(start_tree)


  # alternative alingments
  alt_msas <- foreach(i = 1:(Ntip(start_tree)-3)) %do% {
    align_part_set(input_seq = seq, align_parts[,i])
  }

  alt_msas <- foreach(i = 1:length(alt_msas), .combine = c) %do% {
    alt_msas[[i]]
  }


  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  # ##############################################

  ####

  if (inherits(seq, "DNAbin")){
    alt_msas <- lapply(alt_msas, as.character)
  }
  # if (inherits(seq, "AAbin")){
  #   alt_msas <- lapply(alt_msas, function(x) do.call(rbind, x))
  # }

  alt_msas <- lapply(alt_msas, function(x) as.data.frame(t(x)))
  base.msa.t <- data.frame(t(as.character(base.msa)))

  ## match sequence names
  for(i in 1:length(alt_msas)){
    alt_msas[[i]] <- alt_msas[[i]][,match(colnames(base.msa.t), colnames(alt_msas[[i]]))]
  }

  if (parallel){
    pb <- txtProgressBar(max = length(alt_msas), style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    bpres <- foreach(i = 1:length(alt_msas), .options.snow = opts,
      .export = 'calc_scores') %dopar% {
        calc_scores(ref = base.msa.t, com = alt_msas[[i]])
      }
    stopCluster(cl)
  }
  close(pb)

  ## Column Reliability
  crb <- do.call(cbind, lapply(bpres, function(x) x[[1]]))
  del <- grep("V1", names(crb))
  crb <- crb[, -del[2:length(del)]]
  crb <- data.frame(col = crb[, 1], guidance_score = rowMeans(crb[,2:ncol(crb)]))

  ## alignment reliability
  alignment_reliability <- mean(crb[, 2])

  ## residue reliability
  rrb <- do.call(cbind, lapply(bpres, function(x) x[[2]]))
  del <- grep("V1|V2", names(rrb))
  rrb <- rrb[,-del[3:length(del)]]
  rrb <- data.frame(rrb[,1:2], rowMeans(rrb[,3:ncol(rrb)]))
  colnames(rrb) <- c("col", "row", "residue_score")

  ## sequence reliability
  srb <- do.call(cbind, lapply(bpres, function(x) x[[3]]))
  del <- grep("V1", names(srb))
  srb <- srb[,-del[2:length(del)]]
  srb <- data.frame(row = srb[,1], sequence_score = rowMeans(srb[,2:ncol(srb)]))

  ## remove unreliable columns
  remove_cols <- crb[,2] < cutoff
  HoT.msa <- base.msa[,!remove_cols]

  # if(mask == TRUE){
  #   if(inherits(seq, "DNAbin")){     base.msa[###<0.5 & base.msa!="-"] <- "N" }
  #   if(inherits(seq, "AAbin")) {     base.msa[###<0.5 & base.msa!="-"] <- "X"  }
  # }

  ## prepare base.msa for output
  if(inherits(seq, "DNAbin")){   base.msa <- as.DNAbin(base.msa) }
  if(inherits(seq, "AAbin")) {   base.msa <- as.AAbin(base.msa)  }

  ## prepare base.msa for output
  if(inherits(seq, "DNAbin")){   HoT.msa <- as.DNAbin(HoT.msa) }
  if(inherits(seq, "AAbin")) {   HoT.msa <- as.AAbin(HoT.msa)  }

  res <-  list(alignment_reliability = alignment_reliability,
    residue_reliability = rrb,
    column_reliability = crb,
    sequence_reliability = srb,
    HoT_MSA = HoT.msa,
    base_msa = base.msa)

  return(res)
}

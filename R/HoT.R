#' Heads or Tails alignment reliability
#' @description Assess reliability in an aligment using the
#'   HoT algorithm
#' @param sequences An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequencesuences of DNA or amino acids.#' @param cutoff specifies a cutoff to remove unreliable columns below the cutoff
#' @param cutoff specifies a cutoff to remove unreliable columns below the
#'   cutoff
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty either \code{"mafft"} (default) or\code{"prank"}.
#' @param mafft_exec A character string giving the path to the executable of MAFFT
#'   (usually: '/usr/local/bin/mafft')
#' @param method further arguments passed to MAFFT, default is "auto"
#' @param mask specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA)
#'
#' @return alignment_reliability
#' @return residue_reliability
#' @return sequencesuence_reliability
#' @return column_reliability
#' @return HoT_MSA: is the base MSA removed from unreliable columns below
#'   \code{cutoff}
#' @return base_msa
#'
#' @details Calculates column reliability by comparing alternative
#'   MSAs generated by aligning guide tree partitions.
#' @author Franz-Sebastian Krah
#' @references G. Landan and D. Graur (2008). Local reliability measures from sets of co-optimal multiple sequencesuence alignments. 13:15--24
#'
#' @importFrom ips mafft
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#' @import adephylo
#' @importFrom phytools plotTree
#'
#' @author Franz-Sebastian Krah
#' @author Christoph Heibl
#' @export


HoT <- function(sequences, cutoff = 0.93, parallel = FALSE, ncore,
  msa.program = "mafft", method = "auto", mask = FALSE,
  mafft_exec, plot_guide = TRUE){


  if (missing(mafft_exec)) mafft_exec <- "/usr/local/bin/mafft"

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, "DNAbin") & !inherits(sequences[[1]], "AAbin"))
    stop("sequencesuences not of class DNAbin or AAbin (ape)")


  ##############################################
  ## PART I
  ##############################################
  ## BASE and alternative MSAs
  ##############################################
  # sequences_nam <- names(sequences)

  ## Generate BASE MSA
  if (msa.program == "mafft"){
    # base.msa <- mafft_AA(sequences, method = method)
    # C  On my MAC mafft is in /usr/local/bin/ but function is not working
    base.msa <- mafft(sequences, method = method, exec = mafft_exec)
  }

  ## calculate start guide tree
  base.msa.ml <- as.phyDat(base.msa)
  # find ML distance as input to nj tree search
  ml.dist.msa <- dist.ml(base.msa.ml)
  # NJ
  start_tree <- ape::nj(ml.dist.msa)
  start_tree <- multi2di(start_tree)
  start_tree <- compute.brlen(start_tree)

  # plot guide tree
  if(plot_guide){
    phytools::plotTree(start_tree)
    legend("bottomleft",
      paste(Ntip(start_tree)," tips","; ",
        Ntip(start_tree)-3, " partitions", sep =""),
      bty = "n")
  }

  ## produce MSA partitions
  align_parts <- partitions(start_tree)

  # alternative alingments
  if (parallel){
  pb <- txtProgressBar(max = (Ntip(start_tree)-3), style = 3)
  # progress <- function(n) setTxtProgressBar(pb, n)
  # opts <- list(progress = progress)

  cl <- makeCluster(ncore)
  registerDoSNOW(cl)
  alt_msas <- list()
  for(i in 1:(Ntip(start_tree)-3)){ ## foreach does not work
    setTxtProgressBar(pb, i)
    alt_msas[[i]] <- align_part_set(x = sequences,
      partition_set = align_parts[,i],
      method = method, mafft_exec = mafft_exec)
  }
  stopCluster(cl)
  }
  if (!parallel){
    pb <- txtProgressBar(min = 0, max = (Ntip(start_tree)-3), style = 3)
    alt_msas <- foreach(i = 1:(Ntip(start_tree)-3)) %do% {
      setTxtProgressBar(pb, i)
      align_part_set(x = sequences, partition_set = align_parts[,i],
        method = method, mafft_exec = mafft_exec)
      if(plot_guide){
        # phytools::plotTree(start_tree)
        nodelabels(pch = 16, cex = 1.5, col = "red",
          node = as.numeric(gsub("X", "", names(align_parts)[i])))
      }
    }
  }
  close(pb)

  ## unlist
  alt_msas <- foreach(i = 1:length(alt_msas), .combine = c) %do% {
    alt_msas[[i]]
  }


  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  # ##############################################

  ####
  base.msa.t <- data.frame(t(as.character(base.msa)))
  alt_msas <- lapply(alt_msas, function(x) data.frame(t(as.character(x))))

  ## match sequencesuence names
  for(i in 1:length(alt_msas)){
    alt_msas[[i]] <- alt_msas[[i]][,match(colnames(base.msa.t),
      colnames(alt_msas[[i]]))]
  }
  ##
  if (!parallel){
    pb <- txtProgressBar(max = length(alt_msas), style = 3)
    altres <- foreach(i = 1:length(alt_msas),
      .export = 'calc_scores') %do% {
        setTxtProgressBar(pb, i)
        calc_scores(ref = base.msa.t, com = alt_msas[[i]])
      }
  }
  if (parallel){
    pb <- txtProgressBar(max = length(alt_msas), style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    altres <- foreach(i = 1:length(alt_msas), .options.snow = opts,
      .export = 'calc_scores') %dopar% {
        calc_scores(ref = base.msa.t, com = alt_msas[[i]])
      }
    stopCluster(cl)
  }
  close(pb)

  ## Column Reliability
  crb <- do.call(cbind, lapply(altres, function(x) x[[1]]))
  del <- grep("V1", names(crb))
  crb <- crb[, -del[2:length(del)]]
  crb <- data.frame(col = crb[, 1], guidance_score = rowMeans(crb[,2:ncol(crb)]))

  ## alignment reliability
  alignment_reliability <- mean(crb[, 2])

  ## residue reliability
  rrb <- do.call(cbind, lapply(altres, function(x) x[[2]]))
  del <- grep("V1|V2", names(rrb))
  rrb <- rrb[,-del[3:length(del)]]
  rrb <- data.frame(rrb[,1:2], rowMeans(rrb[,3:ncol(rrb)]))
  colnames(rrb) <- c("col", "row", "residue_score")

  ## sequencesuence reliability
  srb <- do.call(cbind, lapply(altres, function(x) x[[3]]))
  del <- grep("V1", names(srb))
  srb <- srb[,-del[2:length(del)]]
  srb <- data.frame(row = srb[,1], sequencesuence_score = rowMeans(srb[,2:ncol(srb)]))

  ## remove unreliable columns
  remove_cols <- crb[,2] < cutoff
  HoT.msa <- base.msa[,!remove_cols]

  # if(mask == TRUE){
  #   if(inherits(sequences, "DNAbin")){     base.msa[###<0.5 & base.msa!="-"] <- "N" }
  #   if(inherits(sequences, "AAbin")) {     base.msa[###<0.5 & base.msa!="-"] <- "X"  }
  # }


  res <-  list(alignment_reliability = alignment_reliability,
    residue_reliability = rrb,
    column_reliability = crb,
    sequence_reliability = srb,
    HoT_MSA = HoT.msa,
    base_msa = base.msa)

  return(res)
}

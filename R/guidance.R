
#' @title Alignment Confidence Scores with GUIDANCE
#' @description Assess uncertainty in multiple sequence aligment (MSA) with the
#'   GUIDANCE algorithm (Penn et al. 2010).
#' @param seqs An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequences of DNA or amino acids.
#' @param cutoff specifies a cutoff to remove unreliable columns below the
#'   cutoff
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param bootstrap An integer giving the number of perturbated MSAs.
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty either \code{"mafft"} (default) or\code{"prank"}.
#' @param exec A character string giving the path to the executable of the
#'   alignment program.
#' @param method further arguments passed to mafft, default is "auto"
#'
#' @return alignment_score: is the GUIDANCE alignment score
#' @return GUIDANCE_residue_score
#' @return GUIDANCE_score: is the GUIDANCE column score
#' @return GUIDANCE_sequence_score
#' @return guidance_msa: is the base MSA removed from unreliable columns below
#'   cutoff
#' @return base_msa
#'
#' @details Calculates column unreliability by comparing alternative bootstrap
#'   MSAs (Felsenstein 1985) generated by different guide trees. Thus GUIDANCE
#'   is a measure for guide-tree uncertainty. The basic comparison between the
#'   BP MSAs and a reference MSA is if column residue pairs are identical in
#'   both MSAs.
#' @author Franz-Sebastian Krah
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783–791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#'
#' @import ips
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @export

guidance <- function(seqs, cutoff = 0.93, parallel = FALSE, ncore,
  bootstrap = 100, msa.program = "mafft", exec, method = "auto"){

  if (!is.object(seqs)){
    seqs <- read.FASTA(seqs)
  }

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(seqs, c("DNAbin", "AAbin")))
    stop("sequences must be of class DNAbin or AAbin (ape)")

  ##############################################
  ## PART I
  ##############################################
  ## BASE and PERTUBATED MSAs
  ##############################################


  ## Generate BASE alignment
  ###########################
  cat("Generating the base alignment \n")
  if (msa.program == "mafft"){
    base.msa <- mafft(seqs, method = method, exec = exec)
  }
  if (msa.program == "prank"){
    base.msa <- prank(seqs)
  }

  ## Constructing BP guide-trees for the pertubated MSAs
  #######################################################
  cat("Pertubating base alignment \n")
  pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)

  base.msa.bp <- foreach(i = 1:bootstrap) %do% {
    setTxtProgressBar(pb, i)
    # set.seed(8463251)
    pertubatedMSA <- base.msa[, sample(ncol(base.msa), replace = TRUE)]
    return(pertubatedMSA)
  }
  close(pb)

  ## Generating alternative (pertubated) MSAs
  ###########################################
  cat("Generating alternative alignments \n")

  ## Compute NJ guide trees
  cat("  Generating NJ guide trees \n")
  if (parallel == TRUE){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    nj.guide.trees <- foreach(i = 1:bootstrap, .options.snow = opts) %dopar% {
      # convert to class phyDAT
      base.msa.ml <- phangorn::as.phyDat(base.msa.bp[[i]])
      # find ML distance as input to nj tree search
      ml.dist.msa <- phangorn::dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
    stopCluster(cl)
  }
  if (parallel == FALSE){
    nj.guide.trees <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      # convert to class phyDAT
      base.msa.ml <- phangorn::as.phyDat(base.msa.bp[[i]])
      # find ML distance as input to nj tree search
      ml.dist.msa <- phangorn::dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
  }
  close(pb)


  ## Find NJ tree for base MSA
  ## 1st tip label of base.nj tree as outgroup for all guide.njs
  base.nj <- ape::nj(phangorn::dist.ml(phangorn::as.phyDat(base.msa)))
  base.nj <- root(base.nj, outgroup = base.nj$tip.label[1])

  ## Root each tree on the first tip label of the base.nj tree
  nj.guide.trees <- lapply(nj.guide.trees, root,
    outgroup = base.nj$tip.label[1],
    resolve.root = TRUE)

  ## Rescale branch lengths
  nj.guide.trees <- lapply(nj.guide.trees, compute.brlen)

  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("  Alignment of pertubated MSAs using NJ guide trees \n")
  if (parallel){
    if (msa.program == "mafft"){
      guide.msa <- pbmclapply(nj.guide.trees,
        function(x, seqs, method) mafft(seqs, gt = x, method = method),
        seqs = seqs, method = method,
        mc.cores = ncore, ignore.interactive = TRUE)
    }

    # @Christoph: prank gibt fehler:  object "phy" has no trees
    # problem liegt hier:
    # missingseqs <- which(!guidetree$tip.label %in% x$nam)
    #x$nam müsste names(x) sein...
    if (msa.program == "prank"){
      guide.msa <- pbmclapply(nj.guide.trees,
        FUN = function(y) prank(x = seqs, guidetree = y,
          path = exec),
        mc.cores = ncore, ignore.interactive = TRUE)
    }
  } else {
    pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)
    if (msa.program == "mafft"){
      guide.msa <- foreach(i = 1:bootstrap) %do% {
        mafft(x = seqs, gt = nj.guide.trees[[i]], method = method, exec = exec)
        setTxtProgressBar(pb, i)
      }
    }
    if (msa.program == "prank"){
      guide.msa <- foreach(i = 1:bootstrap) %do% {
        prank(x = seqs, guidetree = nj.guide.trees[[i]],
          path = exec)
        setTxtProgressBar(pb, i)
      }
    }
  }
  close(pb)

  ## CH [2017-03-15]:
  ## Some MAFFT alignments fail. This is not a deterministic
  ## pattern: On another occasion the same dataset gets aligned
  ## with the same NJ guide tree. So there must be some kind of
  ## stochastic process within MAFFT.
  ## My rapid solution is to just delete those replicates
  ## that failed to align. A future solution should try to rerun
  ## the replicates until they succeed.
  failed <- which(sapply(guide.msa, is.integer))
  if (length(failed)){
    cat("  .. failed for", length(failed), "pertubations\n")
    bootstrap <- bootstrap - length(failed)
    guide.msa <- guide.msa[-failed]
  }

  # removing some intermediate objects not further needed
  rm(base.msa.bp)
  rm(nj.guide.trees)

  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  # ##############################################
  # # produce combinations factor matrix

  ####
  # HERE ADD SCORE CODE
  base.msa.t <- data.frame(t(as.character(base.msa)))
  store_guide.msa <- guide.msa
  guide.msa <- lapply(guide.msa, function(x) as.data.frame(t(as.character(x))))

  if (parallel){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    bpres <- foreach(i = 1:bootstrap, .options.snow = opts, .export = 'calc_scores') %dopar% {
      calc_scores(ref = base.msa.t, com = guide.msa[[i]], n_id = i)
    }
    stopCluster(cl)
  }
  close(pb)

  ## GUIDANCE column score
  gsc <- do.call(cbind, lapply(bpres, function(x) x[[1]]))
  del <- grep("V1", names(gsc))
  gsc <- gsc[, -del[2:length(del)]]
  gsc <- data.frame(col = gsc[, 1], guidance_score = rowMeans(gsc[,2:ncol(gsc)]))

  ## GUIDANCE Alignment score
  alignment_score <- mean(gsc[, 2])

  ## GUIDANCE residue score
  grsc <- do.call(cbind, lapply(bpres, function(x) x[[2]]))
  del <- grep("V1|V2", names(grsc))
  grsc <- grsc[,-del[3:length(del)]]
  grsc <- data.frame(grsc[,1:2], rowMeans(grsc[,3:ncol(grsc)]))
  colnames(grsc) <- c("col", "row", "residue_score")

  ## GUIDANCE sequence score
  gssc <- do.call(cbind, lapply(bpres, function(x) x[[3]]))
  del <- grep("V1", names(gssc))
  gssc <- gssc[,-del[2:length(del)]]
  gssc <- data.frame(row = gssc[,1], sequence_score = rowMeans(gssc[,2:ncol(gssc)]))

  ## remove unreliable columns
  guidance.msa <- base.msa[, gsc[, 2] > cutoff]

  ## return results
  list(alignment_score = alignment_score,
               GUIDANCE_residue_score = grsc,
               GUIDANCE_score = gsc,
               GUIDANCE_sequence_score = gssc,
               guidance_msa = guidance.msa,
               base_msa = base.msa)
}

#' GUIDetree-based AligNment ConficencE
#'
#' @param sequencess An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequences of DNA or amino acids.
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores (default is maxinum of local threads)
#' @param bootstrap An integer giving the number of perturbated MSAs.
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty one of c("mafft", "muscle", "clustalo", "clustalw2"); MAFFT is default
#' @param exec A character string giving the path to the executable of the
#'   alignment program.
#' @param method further arguments passed to mafft, default is "auto"
#' @param col.cutoff numberic between 0 and 1; specifies a cutoff to remove unreliable columns below the cutoff; either user supplied or "auto" (0.73)
#' @param seq.cutoff numberic between 0 and 1; specifies a cutoff to remove unreliable sequences below the cutoff; either user supplied of "auto" (0.5)
#' @param mask.cutoff specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA); either user supplied of "auto" (0.5)
#' @description Assess uncertainty in multiple sequence aligment (MSA) with the
#'   GUIDANCE algorithm (Penn et al. 2010).
#' @return alignment_score
#' @return GUIDANCE_residue_score
#' @return GUIDANCE_score: is the GUIDANCE column score
#' @return GUIDANCE_sequence_score
#' @return guidance_msa: is the base MSA removed from unreliable residues/columns/sequences below \code{cutoffs}
#' @return base_msa
#'
#' @details Calculates column confidence by comparing alternative MSAS generated by bootstrap MSAs (Felsenstein 1985) and derived guide trees. The basic comparison between the BP MSAs and a reference MSA is if column residue pairs are identical in both MSAs.
#' @author Franz-Sebastian Krah
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783â€“791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#'
#' @import ips
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @author Franz-Sebastian Krah
#' @author Christoph Heibl
#' @export

guidance <- function(sequences,
  msa.program = "mafft", exec,
  bootstrap = 100,
  col.cutoff = "auto",
  seq.cutoff = "auto",
  mask.cutoff = "auto",
  parallel = FALSE, ncore ="auto",
  method = "auto",
  alt.msas.file){

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, c("DNAbin", "AAbin")))
    stop("sequences not of class DNAbin or AAbin (ape)")

  type <- class(sequences)
  type <- gsub("bin", "", type)


  if (length(labels(sequences)) < 8)
    warning("GUIDANCE is not suitable for alignments of very few sequences.\n
              As a rule of thumb, use GUIDANCE2 or HoT for less than 8 sequences.")

  ## Check for MSA program
  if(missing(exec)){
    os <- Sys.info()[1]
    if (msa.program =="mafft") {
      exec <- switch(os, Linux = "mafft", Darwin = "mafft",
        Windows = "mafft.bat")
    }
    if (msa.program =="muscle") {
      exec <- switch(os, Linux = "muscle", Darwin = "muscle",
        Windows = "muscle3.8.31_i86win32.exe")
    }
    if (msa.program =="clustalo") {
      exec <- switch(os, Linux = "clustalo", Darwin = "clustalo",
        Windows = "clustalo.exe")
    }
    if (msa.program =="clustalw2") {
      exec <- switch(os, Linux = "clustalw", Darwin = "clustalw2",
        Windows = "clustalw2.exe")
    }
  }
  out <- system(paste(exec, "--v", sep=" "), ignore.stdout = TRUE, ignore.stderr = TRUE)
  if (out == 127)
    stop("please provide exec path or install MSA program in root \n
      i.e. in Unix: '/usr/local/bin/mafft'")

  if(ncore=="auto"){
    ncore <- detectCores(all.tests = FALSE, logical = TRUE)
  }

  ##############################################
  ## PART I
  ##############################################
  ## BASE and PERTUBATED MSAs
  ##############################################

  ## Generate BASE alignment
  ###########################
  cat("Generating the base alignment")
  if (msa.program == "mafft"){
    base.msa <- mafft(sequences, method = method, exec = exec)
  }
  if (msa.program == "muscle"){
    base.msa <- muscle2(sequences, exec = exec)
  }
  if (msa.program == "clustalo"){
    base.msa <- clustalo(x = sequences, exec = exec)
  }
  if (msa.program == "clustalw2"){
    base.msa <- clustalw2(x = sequences, exec = exec)
  }

  cat("... done \n")

  ## form into matrix for perturbation
  base.msa <- as.character(base.msa)

  ## Constructing BP guide-trees for the pertubated MSAs
  #######################################################
  cat("Pertubating base alignment\n")

  pb <- txtProgressBar(max = bootstrap, style = 3)
  if(inherits(sequences, "DNAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      as.DNAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])
    }
  }
  if(inherits(sequences, "AAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      as.AAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])

    }
  }
  close(pb)

  ## Generating alternative (pertubated) MSAs
  ###########################################
  cat("Generating alternative alignments \n")

  ## Compute NJ guide trees
  cat("  Generating NJ guide trees \n")
  if (parallel){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    nj.guide.trees <- foreach(i = 1:bootstrap,
      .options.snow = opts, .packages = "phangorn") %dopar% {
        # convert to class phyDAT
        # base.msa.ml <- as.phyDat(base.msa.bp[[i]])
        base.msa.ml <- as.phyDat(as.character(base.msa.bp[[i]]))
        # find ML distance as input to nj tree search
        ml.dist.msa <- dist.ml(base.msa.ml)
        # NJ
        ape::nj(ml.dist.msa)
      }
    stopCluster(cl)
  }
  if (!parallel){
    nj.guide.trees <- foreach(i = 1:bootstrap, .packages = "phangorn") %do% {
      setTxtProgressBar(pb, i)
      # convert to class phyDAT
      base.msa.ml <- as.phyDat(base.msa.bp[[i]])
      # find ML distance as input to nj tree search
      ml.dist.msa <- dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
  }
  close(pb)


  ## Find NJ tree for base MSA
  ## 1st tip label of base.nj tree as outgroup for all guide.njs
  base.nj <- ape::nj(dist.ml(as.phyDat(base.msa)))
  base.nj <- root(base.nj, outgroup = base.nj$tip.label[1])

  ## Root each tree on the first tip label of the base.nj tree
  nj.guide.trees <- lapply(nj.guide.trees, root,
    outgroup = base.nj$tip.label[1],
    resolve.root = TRUE)

  ## Rescale branch lengths
  nj.guide.trees <- lapply(nj.guide.trees, compute.brlen)

  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("\n  Alignment of pertubated MSAs using NJ guide trees \n")

  msa_out <- vector(length = bootstrap)
  for (i in seq_along(msa_out))
    msa_out[i] <- tempfile(pattern = "mafft", tmpdir = tempdir(), fileext = ".fas")
  unlink(msa_out[file.exists(msa_out)])

  pb <- txtProgressBar(max = bootstrap, style = 3)

  if (parallel){
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)
    cl <- makeCluster(ncore)
    registerDoSNOW(cl)

    if (msa.program == "mafft"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'),
        .options.snow = opts)  %dopar% {
          mafft2(x = sequences, gt = nj.guide.trees[[i]],
            exec = exec, file = msa_out[i], method = method)
        }
    }
    if (msa.program == "muscle"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'),
        .options.snow = opts)  %dopar% {
          muscle2(x = sequences, gt = nj.guide.trees[[i]],
            exec = exec, file = msa_out[i])
        }
    }
    if (msa.program == "clustalo"){
      foreach(i = 1:bootstrap, .packages =c('ips', 'ape'),
        .options.snow = opts)  %dopar% {
          clustalo(x = sequences, gt = nj.guide.trees[[i]],
            exec = exec, file = msa_out[i])

        }
    }
    if (msa.program == "clustalw2"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'),
        .options.snow = opts)  %dopar% {
          clustalw2(x = sequences, gt = nj.guide.trees[[i]],
            exec = exec, file = msa_out[i])
        }
    }
    stopCluster(cl)
  }

  if (!parallel){
    if (msa.program == "mafft"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'))  %do% {
        setTxtProgressBar(pb, i)
        mafft2(x = sequences, gt = nj.guide.trees[[i]],
          method = method, exec = exec, file = msa_out[i])
        }
    }
    if (msa.program == "muscle"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'))  %do% {
        setTxtProgressBar(pb, i)
        muscle2(x = sequences, gt = nj.guide.trees[[i]],
          exec = exec, file = msa_out[i])
        }
    }
    if (msa.program == "clustalo"){
      foreach(i = 1:bootstrap, .packages =c('ips', 'ape'))  %do% {
        setTxtProgressBar(pb, i)
        clustalo(x = sequences, gt = nj.guide.trees[[i]],
          exec = exec, file = msa_out[i])
        }
    }
    if (msa.program == "clustalw2"){
      foreach(i = 1:bootstrap, .packages=c('ips', 'ape'))  %do% {
        setTxtProgressBar(pb, i)
        clustalw2(x = sequences, gt = nj.guide.trees[[i]],
          exec = exec, file = msa_out[i])
        }
    }
  }
  close(pb)

  mafft_created <- list.files(getwd(),
    full.names = T)[grep("tree.mafft", list.files(getwd()))]
  if(length(mafft_created)>0){
    file.remove(mafft_created)
  }

  # removing some intermediate objects not further needed
  rm(base.msa.bp)
  rm(nj.guide.trees)

  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  # ##############################################

  ## produce input format for msa_set_score program
  # transfrom character matrix (sequences are columns)
  base.msa.t <- data.frame(t(base.msa))
  # guide.msa <- lapply(guide.msa, function(x) data.frame(t(as.character(x))))

  pb <- txtProgressBar(max = bootstrap, style = 3)
  if (parallel){
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)
    cl <- makeCluster(ncore)
    registerDoSNOW(cl)

    bpres <- foreach(i = 1:bootstrap, .options.snow = opts,
      .export = 'calc_scores', .packages = "ips") %dopar% {
        guide.msa <- read.fas(msa_out[i], type = type)
        guide.msa <- data.frame(t(as.character(guide.msa)))
        calc_scores(ref = base.msa.t, com = guide.msa)
      }
    stopCluster(cl)
  }
  if (!parallel){
    bpres <- foreach(i = 1:bootstrap,.export = 'calc_scores',
      .packages = 'ips') %do% {
        setTxtProgressBar(pb, i)
        guide.msa <- read.fas(msa_out[i], type =type)
        guide.msa <- data.frame(t(as.character(guide.msa)))
        calc_scores(ref = base.msa.t, com = guide.msa)
      }
  }
  close(pb)

  ##  if wanted, store alternative MSAs into a zip file
  if(!missing(alt.msas.file)){
    files <- list.files(tempdir())
    files <- files[grep("\\.fas", files)]
    for(i in 1:bootstrap){
      file.rename(paste(tempdir(), files[i], sep="/"),
        paste(tempdir(), paste("altMSA", i, ".fas",sep=""), sep="/"))}
    files <- list.files(tempdir(), full.names = TRUE)
    files <- files[grep("altMSA*", files)]
    zip(alt.msas.file, files)
  }
  ## delete temporary files in temporary directory
  unlink(msa_out[file.exists(msa_out)], force = TRUE)
  # unlink(tempdir(), force = TRUE) # do not use this, it causes problems

  ## GUIDANCE column score
  gsc <- do.call(cbind, lapply(bpres, function(x) x[[1]]))
  del <- grep("V1", names(gsc))
  gsc <- gsc[, -del[2:length(del)]]
  gsc <- data.frame(col = gsc[, 1], guidance_score = rowMeans(gsc[,2:ncol(gsc)]))

  ## GUIDANCE Alignment score
  alignment_score <- mean(gsc[, 2])

  ## GUIDANCE residue score
  grsc <- do.call(cbind, lapply(bpres, function(x) x[[2]]))
  del <- grep("V1|V2", names(grsc))
  grsc <- grsc[,-del[3:length(del)]]
  grsc <- data.frame(grsc[,1:2], rowMeans(grsc[,3:ncol(grsc)]))
  colnames(grsc) <- c("col", "row", "residue_score")

  ## GUIDANCE sequence score
  gssc <- do.call(cbind, lapply(bpres, function(x) x[[3]]))
  del <- grep("V1", names(gssc))
  gssc <- gssc[,-del[2:length(del)]]
  gssc <- data.frame(row = gssc[,1], sequence_score = rowMeans(gssc[,2:ncol(gssc)]))


  msa <- guidance.msa <- base.msa
  ## masking residues below cutoff
  if (mask.cutoff>0){
    txt <- as.vector(as.character(base.msa))
    mat <- data.frame(grsc, txt)
    rown <- max(mat$row)
    coln <- max(mat$col)
    res_mat <- matrix(mat$residue_score, nrow = rown, ncol = coln)

    if (mask.cutoff=="auto"){ mask.cutoff <- 0.50 }

    if (inherits(sequences, "DNAbin")){
      msa[res_mat<mask.cutoff & !is.na(res_mat)] <- "N"
      msa <- as.DNAbin(msa)
      rownames(msa) <- labels(sequences)
    }
    if (inherits(sequences, "AAbin")) {
      msa[res_mat<mask.cutoff & !is.na(res_mat)] <- "X"
      rownames(msa) <- labels(sequences)
      class(msa) <- "AAbin"
    }
    guidance.msa <- msa
  }
  ## remove unreliable columns
  if (col.cutoff>0){
    ifelse(mask.cutoff>0, msa <- guidance.msa, msa <- base.msa)
    if(col.cutoff =="auto"){col.cutoff <- 0.97}
    remove_cols <- gsc[,2] < col.cutoff
    guidance.msa <- msa[,!remove_cols]
  }
  ## remove unreliable sequences
  if (seq.cutoff>0){
    ifelse(mask.cutoff>0, msa <- guidance.msa, msa <- base.msa)
    if (seq.cutoff =="auto"){seq.cutoff <- 0.5}
    remove_sequences <- gssc$sequence_score < seq.cutoff
    guidance.msa <- msa[!remove_sequences,]
  }

  ## prepare base.msa for output
  if(inherits(sequences, "DNAbin")){   base.msa <- as.DNAbin(base.msa) }
  if(inherits(sequences, "AAbin")) {   base.msa <- as.AAbin(base.msa)  }

  ## Produce output
  res <-  list(alignment_score = alignment_score,
    GUIDANCE_residue_score = grsc,
    GUIDANCE_score = gsc,
    GUIDANCE_sequence_score = gssc,
    guidance_msa =guidance.msa,
    base_msa = base.msa)

  return(res)
}

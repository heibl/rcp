#' GUIDetree-based AligNment ConficencE
#'
#'
#' @param seq is the raw input sequences of class DNAbin (DNA) or SeqFastaAA (AA)
#' @param cutoff specifies a cutoff to remove unreliable columns below the cutoff
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param bootstrap number of perturbated MSAs (default = 100)
#' @param msa.program one of c("mafft", "prank"), default is MAFFT
#' @param method further arguments passed to mafft, default is "auto"
#' @mask specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA)
#'
#' @return alignment_score: is the GUIDANCE alignment score
#' @return GUIDANCE_residue_score
#' @return GUIDANCE_score: is the GUIDANCE column score
#' @return GUIDANCE_sequence_score
#' @return guidance_msa: is the base MSA removed from unreliable columns below cutoff
#' @return base_msa
#'
#' @details Calculates column unreliability by comparing alternative bootstrap MSAs (Felsenstein 1985) generated by different guide trees. Thus GUIDANCE is a measure for guide-tree uncertainty. The basic comparison between the BP MSAs and a reference MSA is if column residue pairs are identical in both MSAs.
#'
#'@references Felsenstein J. 1985. Confidence limits on phylogenies: an approach using the bootstrap. Evolution 39:783–791
#' @references Penn et a. (2010). An alignment confidence score capturing robustness to guide tree uncertainty. Molecular Biology and Evolution 27:1759--1767
#'
#'
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @import phangorn
#'
#' @author Franz-Sebastian Krah

guidance <- function(seq, cutoff = 0.93, parallel = FALSE, ncore,
  bootstrap = 100, msa.program = "mafft", method = "auto", mask = FALSE){

  if (length(grep("\\.fas", seq))> 0){
    seq <- read.FASTA(seq)
  }

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(seq, "DNAbin") & !inherits(seq[[1]], "SeqFastaAA"))
    stop("sequences not of class DNAbin (ape) or SeqFastaAA (seqinr)")


  ##############################################
  ## PART I
  ##############################################
  ## BASE and PERTUBATED MSAs
  ##############################################
  seq_nam <- names(seq)


  ## if AA Sequences perform data prep first
  if(inherits(seq[[1]], "SeqFastaAA")){
    seq <- lapply(seq, as.character)
    seq <- rbind.fill(lapply(seq,
      function(y) { as.data.frame(t(y), stringsAsFactors=FALSE) }))
    seq <- as.AAbin(as.matrix(seq))
  }

  ## Generate BASE alignment
  ###########################
  cat("Generating the base alignment \n")
  if (msa.program == "mafft"){
    base.msa <- mafft_AA(seq, method = method)
  }
  if (msa.program == "prank"){
    base.msa <- ips::prank(seq)
  }
  if(inherits(seq, "DNAbin")){   base.msa <- as.character(base.msa) }
  if(inherits(seq, "AAbin")){    base.msa <- do.call(rbind, base.msa) }

  rownames(base.msa) <- seq_nam


  ## Constructing BP guide-trees for the pertubated MSAs
  #######################################################
  cat("Pertubating base alignment \n")
  pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)

  if(inherits(seq, "DNAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      pertubatedMSA <- as.DNAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])
      return(pertubatedMSA)
    }
  }
  if(inherits(seq, "AAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      pertubatedMSA <- as.AAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])
      return(pertubatedMSA)
    }
  }
  close(pb)


  ## Generating alternative (pertubated) MSAs
  ###########################################
  cat("Generating alternative alignments \n")

  ## Compute NJ guide trees
  cat("  Generating NJ guide trees \n")
  if (parallel == TRUE){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    nj.guide.trees <- foreach(i = 1:bootstrap, .options.snow = opts) %dopar% {
      # convert to class phyDAT
      # base.msa.ml <- phangorn::as.phyDat(base.msa.bp[[i]])
      base.msa.ml <- phangorn::as.phyDat(as.character(base.msa.bp[[i]]))
      # find ML distance as input to nj tree search
      ml.dist.msa <- phangorn::dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
    stopCluster(cl)
  }
  if (parallel == FALSE){
    nj.guide.trees <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      # convert to class phyDAT
      base.msa.ml <- phangorn::as.phyDat(base.msa.bp[[i]])
      # find ML distance as input to nj tree search
      ml.dist.msa <- phangorn::dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
  }
  close(pb)


  ## Find NJ tree for base MSA
  ## 1st tip label of base.nj tree as outgroup for all guide.njs
  base.nj <- ape::nj(phangorn::dist.ml(phangorn::as.phyDat(base.msa)))

  ## Root each tree on the first tip label of the base.nj tree
  nj.guide.trees <- lapply(nj.guide.trees, root,
    outgroup = base.nj$tip.label[1],
    resolve.root = TRUE)

  ## Rescale branch lengths
  nj.guide.trees <- lapply(nj.guide.trees, compute.brlen)

  ## Alignment of MSA BP times with new NJ guide trees
  cat("  Alignment of pertubated MSAs using NJ guide trees \n")
  names(seq) <- seq_nam

  if (parallel == TRUE){
    # guide.msa <- pbmclapply(nj.guide.trees,
    #                         function(x, m, gt) ips::mafft(x, method, gt),
    #                         x = seq, m = method,
    #                         mc.cores = ncore, ignore.interactive = TRUE)

    if(msa.program == "mafft"){
      guide.msa <- pbmclapply(nj.guide.trees,
        FUN = function(x) mafft_AA(x = seq, gt = x, method = method),
        mc.cores = ncore, ignore.interactive = TRUE)
    }

    # @Christoph: prank gibt fehler:  object "phy" has no trees
    # problem liegt hier:
    # missingseqs <- which(!guidetree$tip.label %in% x$nam)
    # x$nam müsste names(x) sein...
    if(msa.program == "prank"){
      guide.msa <- pbmclapply(nj.guide.trees,
        FUN = function(y) ips::prank(x = seq, guidetree = y,
          path = "Applications/prank/bin/prank"),
        mc.cores = ncore, ignore.interactive = TRUE)
    }
  }

  if (parallel == FALSE){

    pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)
    if(msa.program == "mafft"){
      guide.msa <- foreach(i = 1:bootstrap) %do% {
        ips::mafft(x = seq, gt = nj.guide.trees[[i]])
        setTxtProgressBar(pb, i)
      }
    }
    if(msa.program == "prank"){
      guide.msa <- foreach(i = 1:bootstrap) %do% {
        ips::prank(x = seq, guidetree = nj.guide.trees[[i]],
          path ="Applications/prank/bin/prank")
        setTxtProgressBar(pb, i)
      }
    }
  }
  close(pb)

  mafft_created <- list.files(getwd(),
    full.names = T)[grep("tree.mafft", list.files(getwd()))]
  if(length(mafft_created)>0){
    file.remove(mafft_created)
  }
  rm(mafft_created)


  # remooving some intermediate objects not further needed
  rm(base.msa.bp)
  rm(nj.guide.trees)


  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # load(file ="dev/GUIDANCE_in_R/out/guide.msa_10.rda")
  # load(file ="dev/GUIDANCE_in_R/out/base.msa_10.rda")
  # load(file ="dev/GUIDANCE_in_R/out/guide.msa_200.rda")
  # load(file ="dev/GUIDANCE_in_R/out/base.msa_200.rda")


  # ## GUIDANCE Score
  # ##############################################
  # # produce combinations factor matrix


  ####
  # HERE ADD SCORE CODE
  base.msa.t <- data.frame(t(base.msa))
  if(inherits(seq, "DNAbin")){     guide.msa <- lapply(guide.msa, as.character) }
  if(inherits(seq, "AAbin")){
    guide.msa <- lapply(guide.msa, function(x) do.call(rbind, x))
  }
  guide.msa <- lapply(guide.msa, function(x) as.data.frame(t(x)))


  if (parallel == TRUE){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    bpres <- foreach(i = 1:bootstrap, .options.snow = opts, .export='calc_scores') %dopar% {
      calc_scores(com = guide.msa[[i]], ref = base.msa.t, n_id = i)
    }
    stopCluster(cl)
  }
  close(pb)
  ## GUIDANCE column score
  gsc <- do.call(cbind, lapply(bpres, function(x) x[[1]]))
  del <- grep("V1", names(gsc))
  gsc <- gsc[,-del[2:length(del)]]
  gsc <- data.frame(col = gsc[,1], guidance_score = rowMeans(gsc[,2:ncol(gsc)]))

  ## GUIDANCE Alignment score
  alignment_score <- mean(gsc[,2])

  ## GUIDANCE residue score
  grsc <- do.call(cbind, lapply(bpres, function(x) x[[2]]))
  del <- grep("V1|V2", names(grsc))
  grsc <- grsc[,-del[3:length(del)]]
  grsc <- data.frame(grsc[,1:2], rowMeans(grsc[,3:ncol(grsc)]))
  colnames(grsc) <- c("col", "row", "residue_score")

  ## GUIDANCE sequence score
  gssc <- do.call(cbind, lapply(bpres, function(x) x[[3]]))
  del <- grep("V1", names(gssc))
  gssc <- gssc[,-del[2:length(del)]]
  gssc <- data.frame(row = gssc[,1], sequence_score = rowMeans(gssc[,2:ncol(gssc)]))

  ## remove unreliable columns
  remove_cols <- gsc[,2] < cutoff
  guidance.msa <- base.msa[,!remove_cols]

  if(mask == TRUE){
    if(inherits(seq, "DNAbin")){     base.msa[base.msa<0.5 & base.msa!="-"] <- "N" }
    if(inherits(seq, "AAbin")) {     base.msa[base.msa<0.5 & base.msa!="-"] <- "X"  }
  }


  if(inherits(seq, "DNAbin")){ guidance.msa <- as.DNAbin(guidance.msa) }
  if(inherits(seq, "AAbin")) { guidance.msa <- as.AAbin(guidance.msa)  }


  ## prepare base.msa for output
  if(inherits(seq, "DNAbin")){   base.msa <- as.DNAbin(base.msa) }
  if(inherits(seq, "AAbin")) {   base.msa <- as.AAbin(base.msa)  }

  ## Produce output
  res <-  list(alignment_score = alignment_score,
    GUIDANCE_residue_score = grsc,
    GUIDANCE_score = gsc,
    GUIDANCE_sequence_score = gssc,
    guidance_msa =guidance.msa,
    base_msa = base.msa)

  ## Return output
  return(res)

}

#' GUIDetree-based AligNment ConficencE
#'
#' @param seq is the raw input sequences of class DNAbin (DNA) or SeqFastaAA (AA)
#' @param cutoff specifies a cutoff to remove unreliable columns below the cutoff
#' @title Alignment Confidence Scores with GUIDANCE
#' @description Assess uncertainty in multiple sequence aligment (MSA) with the
#'   GUIDANCE algorithm (Penn et al. 2010).
#' @param seqs An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequences of DNA or amino acids.
#' @param cutoff specifies a cutoff to remove unreliable columns below the
#'   cutoff
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param bootstrap An integer giving the number of perturbated MSAs.
#' @param msa.program A charcter string giving the name of the MSA program,
#'   currelty either \code{"mafft"} (default) or\code{"prank"}.
#' @param exec A character string giving the path to the executable of the
#'   alignment program.
#' @param method further arguments passed to mafft, default is "auto"
#' @param mask specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA)
#'
#' @return alignment_score: is the GUIDANCE alignment score
#' @return GUIDANCE_residue_score
#' @return GUIDANCE_score: is the GUIDANCE column score
#' @return GUIDANCE_sequence_score
#' @return guidance_msa: is the base MSA removed from unreliable columns below
#'   cutoff
#' @return base_msa
#'
#' @details Calculates column unreliability by comparing alternative bootstrap
#'   MSAs (Felsenstein 1985) generated by different guide trees. Thus GUIDANCE
#'   is a measure for guide-tree uncertainty. The basic comparison between the
#'   BP MSAs and a reference MSA is if column residue pairs are identical in
#'   both MSAs.
#' @author Franz-Sebastian Krah
#' @references Felsenstein J. 1985. Confidence limits on phylogenies: an
#'   approach using the bootstrap. Evolution 39:783–791
#' @references Penn et al. (2010). An alignment confidence score capturing
#'   robustness to guide tree uncertainty. Molecular Biology and Evolution
#'   27:1759--1767
#'
#' @importFrom ips mafft
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#'
#' @author Franz-Sebastian Krah
#' @author Christoph Heibl

guidance <- function(seq, cutoff = 0.93, parallel = FALSE, ncore,
  bootstrap = 100, msa.program = "mafft", method = "auto", mask = FALSE,
  mafft_exec){


  if (missing(mafft_exec)) mafft_exec <- "/usr/local/bin/mafft"

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(seq, "DNAbin") & !inherits(seq[[1]], "SeqFastaAA"))
    stop("sequences not of class DNAbin (ape) or SeqFastaAA (seqinr)")


  ##############################################
  ## PART I
  ##############################################
  ## BASE and PERTUBATED MSAs
  ##############################################
  seq_nam <- names(seq)


  ## if AA Sequences perform data prep first
  if(inherits(seq[[1]], "SeqFastaAA")){
    seq <- lapply(seq, as.character)
    seq <- rbind.fill(lapply(seq,
      function(y) { as.data.frame(t(y), stringsAsFactors=FALSE) }))
    seq <- as.AAbin(as.matrix(seq))
  }

  ## Generate BASE alignment
  ###########################
  cat("Generating the base alignment \n")
  if (msa.program == "mafft"){
    # base.msa <- mafft_AA(seq, method = method)
  # C  On my MAC mafft is in /usr/local/bin/ but function is not working
    base.msa <- mafft_AA(seq, method = method, exec = exec)
  }
  if (msa.program == "prank"){
    base.msa <- prank(seqs)
  }
  if(inherits(seq, "DNAbin")){   base.msa <- as.character(base.msa) }
  if(inherits(seq, "AAbin")){    base.msa <- do.call(rbind, base.msa) }

  rownames(base.msa) <- seq_nam


  ## Constructing BP guide-trees for the pertubated MSAs
  #######################################################
  cat("Pertubating base alignment \n")
  pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)

  if(inherits(seq, "DNAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      pertubatedMSA <- as.DNAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])
      return(pertubatedMSA)
    }
  }
  if(inherits(seq, "AAbin")){
    base.msa.bp <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      pertubatedMSA <- as.AAbin(base.msa[,sample(ncol(base.msa), replace = TRUE)])
      return(pertubatedMSA)
    }
  }



  ## Generating alternative (pertubated) MSAs
  ###########################################
  cat("Generating alternative alignments \n")

  ## Compute NJ guide trees
  cat("  Generating NJ guide trees \n")
  if (parallel == TRUE){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    nj.guide.trees <- foreach(i = 1:bootstrap, .options.snow = opts) %dopar% {
      # convert to class phyDAT
      # base.msa.ml <- as.phyDat(base.msa.bp[[i]])
      base.msa.ml <- as.phyDat(as.character(base.msa.bp[[i]]))
      # find ML distance as input to nj tree search
      ml.dist.msa <- dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
    stopCluster(cl)
  }
  if (parallel == FALSE){
    nj.guide.trees <- foreach(i = 1:bootstrap) %do% {
      setTxtProgressBar(pb, i)
      # convert to class phyDAT
      base.msa.ml <- as.phyDat(base.msa.bp[[i]])
      # find ML distance as input to nj tree search
      ml.dist.msa <- dist.ml(base.msa.ml)
      # NJ
      ape::nj(ml.dist.msa)
    }
  }
  close(pb)


  ## Find NJ tree for base MSA
  ## 1st tip label of base.nj tree as outgroup for all guide.njs
  base.nj <- ape::nj(dist.ml(as.phyDat(base.msa)))
  base.nj <- root(base.nj, outgroup = base.nj$tip.label[1])

  ## Root each tree on the first tip label of the base.nj tree
  nj.guide.trees <- lapply(nj.guide.trees, root,
    outgroup = base.nj$tip.label[1],
    resolve.root = TRUE)

  ## Rescale branch lengths
  nj.guide.trees <- lapply(nj.guide.trees, compute.brlen)

  ## Alignment of MSA BP times with new NJ guide trees
  ## -------------------------------------------------
  cat("  Alignment of pertubated MSAs using NJ guide trees \n")
  names(seq) <- seq_nam

  # if (parallel == TRUE){
#
#   if(msa.program == "mafft"){
#       guide.msa <- pbmclapply(nj.guide.trees,
#         FUN = function(x) mafft_AA(x = seq, gt = x, method = method),
  if (parallel){
    if (msa.program == "mafft"){
      guide.msa <- pbmclapply(nj.guide.trees,
        function(x, seqs, method) mafft(seqs, gt = x, method = method),
        seqs = seqs, method = method,
        mc.cores = ncore, ignore.interactive = TRUE)
    }
  }

    # @Christoph: prank gibt fehler:  object "phy" has no trees
    # problem liegt hier:
    # missingseqs <- which(!guidetree$tip.label %in% x$nam)
    # x$nam müsste names(x) sein...
  pb <- txtProgressBar(min = 0, max = bootstrap, style = 3)

  if (msa.program == "prank"){
    guide.msa <- pbmclapply(nj.guide.trees,
      FUN = function(y) prank(x = seqs, guidetree = y,
        path = exec), mc.cores = ncore, ignore.interactive = TRUE)
  } else {
    if (msa.program == "mafft"){
      guide.msa <- foreach(i = 1:bootstrap) %do% {
        mafft(x = seqs, gt = nj.guide.trees[[i]], method = method, exec = exec)
        setTxtProgressBar(pb, i)
      }
    }
  }
  close(pb)

  mafft_created <- list.files(getwd(),
    full.names = T)[grep("tree.mafft", list.files(getwd()))]
  if(length(mafft_created)>0){
    file.remove(mafft_created)
  }

  failed <- which(sapply(guide.msa, is.integer))
  if (length(failed)){
    cat("  .. failed for", length(failed), "pertubations\n")
    bootstrap <- bootstrap - length(failed)
    guide.msa <- guide.msa[-failed]
  }

  # removing some intermediate objects not further needed
  rm(base.msa.bp)
  rm(nj.guide.trees)

  ##############################################
  ## PART II
  ##############################################
  ## Computation of GUIDANCE scores
  ##############################################
  cat("Calculating GUIDANCE scores \n")

  # ## GUIDANCE Score
  # ##############################################

  ####
  base.msa.t <- data.frame(t(base.msa))
  if (inherits(seq, "DNAbin")){
    guide.msa <- lapply(guide.msa, as.character)
  }
  if (inherits(seq, "AAbin")){
    guide.msa <- lapply(guide.msa, function(x) do.call(rbind, x))
  }
  guide.msa <- lapply(guide.msa, function(x) as.data.frame(t(x)))

  base.msa.t <- data.frame(t(as.character(base.msa)))
  store_guide.msa <- guide.msa
  guide.msa <- lapply(guide.msa, function(x) as.data.frame(t(as.character(x))))

  if (parallel){
    pb <- txtProgressBar(max = bootstrap, style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    bpres <- foreach(i = 1:bootstrap, .options.snow = opts,
      .export = 'calc_scores') %dopar% {
      calc_scores(ref = base.msa.t, com = guide.msa[[i]], n_id = i)
    }
    stopCluster(cl)
  }
  close(pb)

  ## GUIDANCE column score
  gsc <- do.call(cbind, lapply(bpres, function(x) x[[1]]))
  del <- grep("V1", names(gsc))
  gsc <- gsc[, -del[2:length(del)]]
  gsc <- data.frame(col = gsc[, 1], guidance_score = rowMeans(gsc[,2:ncol(gsc)]))

  ## GUIDANCE Alignment score
  alignment_score <- mean(gsc[, 2])

  ## GUIDANCE residue score
  grsc <- do.call(cbind, lapply(bpres, function(x) x[[2]]))
  del <- grep("V1|V2", names(grsc))
  grsc <- grsc[,-del[3:length(del)]]
  grsc <- data.frame(grsc[,1:2], rowMeans(grsc[,3:ncol(grsc)]))
  colnames(grsc) <- c("col", "row", "residue_score")

  ## GUIDANCE sequence score
  gssc <- do.call(cbind, lapply(bpres, function(x) x[[3]]))
  del <- grep("V1", names(gssc))
  gssc <- gssc[,-del[2:length(del)]]
  gssc <- data.frame(row = gssc[,1], sequence_score = rowMeans(gssc[,2:ncol(gssc)]))

  ## remove unreliable columns
  remove_cols <- gsc[,2] < cutoff
  guidance.msa <- base.msa[,!remove_cols]

  if(mask == TRUE){
    if(inherits(seq, "DNAbin")){     base.msa[base.msa<0.5 & base.msa!="-"] <- "N" }
    if(inherits(seq, "AAbin")) {     base.msa[base.msa<0.5 & base.msa!="-"] <- "X"  }
  }

  ## prepare base.msa for output
  if(inherits(seq, "DNAbin")){   base.msa <- as.DNAbin(base.msa) }
  if(inherits(seq, "AAbin")) {   base.msa <- as.AAbin(base.msa)  }

  ## Produce output
  res <-  list(alignment_score = alignment_score,
    GUIDANCE_residue_score = grsc,
    GUIDANCE_score = gsc,
    GUIDANCE_sequence_score = gssc,
    guidance_msa =guidance.msa,
    base_msa = base.msa)


  return(res)
}

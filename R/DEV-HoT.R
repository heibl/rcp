#' Heads or Tails alignment reliability
#' @description Assess reliability in an aligment using the
#'   HoT algorithm
#' @param sequences An object of class \code{\link{DNAbin}} or \code{\link{AAbin}}
#'   containing unaligned sequencesuences of DNA or amino acids.#' @param cutoff specifies a cutoff to remove unreliable columns below the cutoff
#' @param col.cutoff numberic between 0 and 1; specifies a cutoff to remove unreliable columns below the cutoff; either user supplied or "auto" (0.73)
#' @param seq.cutoff numberic between 0 and 1; specifies a cutoff to remove unreliable sequences below the cutoff; either user supplied of "auto" (0.5)
#'@param mask.cutoff specific residues below a certain cutoff are masked ('N' for DNA, 'X' for AA); either user supplied of "auto" (0.5)
#' @param parallel logical, if TRUE, specify the number of cores
#' @param ncore number of cores
#' @param msa.program A charcter string giving the name of the MSA program,
#'   one of c("mafft", "muscle", "clustalo", "clustalw2"); MAFFT is default
#' @param mafft_exec A character string giving the path to the executable of MAFFT
#'   (usually: '/usr/local/bin/mafft')
#' @param method further arguments passed to MAFFT, default is "auto"
#' @param n.part number of co-optimal alignments should be used (must be integer < Ntip - 3)
#'
#' @return alignment_reliability
#' @return residue_reliability
#' @return sequencesuence_reliability
#' @return column_reliability
#' @return HoT_MSA: is the base MSA removed from unreliable sites and/or sequences and/or masked residues below the cutoffs
#' @return base_msa
#'
#' @details Calculates column reliability by comparing alternative
#'   MSAs generated by aligning guide tree partitions.
#' @author Franz-Sebastian Krah
#' @references G. Landan and D. Graur (2008). Local reliability measures from sets of co-optimal multiple sequencesuence alignments. 13:15--24
#'
#' @import ips
#' @import doSNOW
#' @import foreach
#' @import parallel
#' @import pbmcapply
#' @import plyr
#' @importFrom phangorn as.phyDat dist.ml
#' @import adephylo
#' @importFrom phytools plotTree
#'
#' @author Franz-Sebastian Krah
#' @author Christoph Heibl
#' @export


HoT_dev <- function(sequences,
  msa.program = "mafft", exec,
  n.part = "auto",
  col.cutoff = "auto",
  seq.cutoff = "auto",
  mask.cutoff = "auto",
  parallel = FALSE, ncore,
  method = "auto",
  plot_guide = TRUE){

  ##############################################
  ## SOME CHECKS
  ##############################################
  if (!inherits(sequences, c("DNAbin","AAbin")))
    stop("sequencesuences not of class DNAbin or AAbin (ape)")

  if(length(sequences)>200)
    message("N seq > 200: consider using 'pasta' with desired MSA confidence program")

  ## Check for MSA program
  if(missing(exec)){
    os <- Sys.info()[1]
    if (msa.program =="mafft") {
      exec <- switch(os, Linux = "mafft", Darwin = "mafft",
        Windows = "mafft.bat")
    }
    if (msa.program =="muscle") {
      exec <- switch(os, Linux = "muscle", Darwin = "muscle",
        Windows = "muscle3.8.31_i86win32.exe")
    }
    if (msa.program =="clustalo") {
      exec <- switch(os, Linux = "clustalo", Darwin = "clustalo",
        Windows = "clustalo.exe")
    }
    if (msa.program =="clustalw2") {
      exec <- switch(os, Linux = "clustalw", Darwin = "clustalw2",
      Windows = "clustalw2.exe")
    }
  }
  out <- system(paste(exec, "--v", sep=" "), ignore.stdout = TRUE, ignore.stderr = TRUE)
  if (out == 127)
    stop("please provide exec path or install MSA program in root \n
        i.e. in Unix: '/usr/local/bin/mafft'")

  ## Sequence type, needed for ips::read.fas
  type <- class(sequences)
  type <- gsub("bin", "", type)
  ##############################################
  ## PART I
  ##############################################
  ## BASE and alternative MSAs
  ##############################################
  cat("Generating the base alignment")
  ## MAFFT
  if (msa.program == "mafft"){
    base.msa <- mafft(sequences, method = method, exec = exec)
  }
  if (msa.program == "muscle"){
    base.msa <- muscle2(sequences, exec = exec, type = type)
  }
  if (msa.program == "clustalo"){
    base.msa <- clustalo(x = sequences, exec = exec, type = type)
  }
  if (msa.program == "clustalw2"){
    base.msa <- clustalw2(x = sequences, exec = exec, type =type)
  }

  cat("... done \n")

  cat("Calculate start tree")
  ## calculate start guide tree
  base.msa.ml <- as.phyDat(base.msa)
  # find ML distance as input to nj tree search
  ml.dist.msa <- dist.ml(base.msa.ml)
  # NJ
  start_tree <- ape::nj(ml.dist.msa)
  start_tree <- multi2di(start_tree)
  start_tree <- compute.brlen(start_tree)

  # plot guide tree
  if(plot_guide){
    phytools::plotTree(start_tree)
    legend("bottomleft",
      paste(Ntip(start_tree)," tips","; ",
        Ntip(start_tree)-3, " partitions", sep =""),
      bty = "n")
  }
  cat("... done \n")

  ## produce MSA partitions
  align_parts <- partitions(start_tree)

  ## subsample of partitions (co-optimal solutions)
  if(n.part == "auto"){
    nt <- Ntip(start_tree)
    if(nt>40){
      npart <- nt*0.1
    }else{
      npart <- ncol(align_parts)
    }
    align_parts <- sample(align_parts, npart)
  }else{
    align_parts <- sample(align_parts, n.part)
  }


  ##############################################
  ## PART II
  ##############################################
  ## Co-optimal MSAs
  ##############################################
  cat("Generating co-optimal alignments \n")

  if (parallel){
    pb <- txtProgressBar(max = ncol(align_parts), style = 3)
    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    alt_msas <- list()

    for(i in 1:ncol(align_parts)){ ## foreach does not work
      setTxtProgressBar(pb, i)
      alt_msas[[i]] <- align_part_set(x = sequences,
        partition_set = align_parts[,i],
        method = method, exec = exec, msa.program = msa.program, type = type)
    }
    stopCluster(cl)
  }
  if (!parallel){
    pb <- txtProgressBar(min = 0, max = ncol(align_parts), style = 3)
    alt_msas <- foreach(i = 1:ncol(align_parts)) %do% {
      setTxtProgressBar(pb, i)
      align_part_set(x = sequences, partition_set = align_parts[,i],
        method = method, exec = exec, msa.program = msa.program, type = type)
    }
  }
  close(pb)



  ## unlist
  alt_msas <- foreach(i = 1:length(alt_msas), .combine = c) %do% {
    alt_msas[[i]]
  }


  ##############################################
  ## PART III
  ##############################################
  ## Computation of reliability scores
  ##############################################
  cat("Calculating reliability scores \n")

  ## Transform MSAs for input to *msa_set_score*
  base.msa.t <- data.frame(t(as.character(base.msa)))
  alt_msas <- lapply(alt_msas, function(x) data.frame(t(as.character(x))))

  ## match sequencesuence names
  for(i in 1:length(alt_msas)){
    alt_msas[[i]] <- alt_msas[[i]][,match(colnames(base.msa.t),
      colnames(alt_msas[[i]]))]
  }

  ## Run comparison
  if (!parallel){
    pb <- txtProgressBar(max = length(alt_msas), style = 3)
    altres <- foreach(i = 1:length(alt_msas),
      .export = 'calc_scores') %do% {
        setTxtProgressBar(pb, i)
        calc_scores(ref = base.msa.t, com = alt_msas[[i]])
      }
  }
  if (parallel){
    pb <- txtProgressBar(max = length(alt_msas), style = 3)
    progress <- function(n) setTxtProgressBar(pb, n)
    opts <- list(progress = progress)

    cl <- makeCluster(ncore)
    registerDoSNOW(cl)
    altres <- foreach(i = 1:length(alt_msas), .options.snow = opts,
      .export = 'calc_scores') %dopar% {
        calc_scores(ref = base.msa.t, com = alt_msas[[i]])
      }
    stopCluster(cl)
  }
  close(pb)

  ## Column Reliability
  crb <- do.call(cbind, lapply(altres, function(x) x[[1]]))
  del <- grep("V1", names(crb))
  crb <- crb[, -del[2:length(del)]]
  crb <- data.frame(col = crb[, 1], guidance_score = rowMeans(crb[,2:ncol(crb)]))

  ## alignment reliability
  alignment_reliability <- mean(crb[, 2])

  ## residue reliability
  rrb <- do.call(cbind, lapply(altres, function(x) x[[2]]))
  del <- grep("V1|V2", names(rrb))
  rrb <- rrb[,-del[3:length(del)]]
  rrb <- data.frame(rrb[,1:2], rowMeans(rrb[,3:ncol(rrb)]))
  colnames(rrb) <- c("col", "row", "residue_score")

  ## sequencesuence reliability
  srb <- do.call(cbind, lapply(altres, function(x) x[[3]]))
  del <- grep("V1", names(srb))
  srb <- srb[,-del[2:length(del)]]
  srb <- data.frame(row = srb[,1], sequencesuence_score = rowMeans(srb[,2:ncol(srb)]))



  ## masking residues below cutoff
  if (mask.cutoff>0 ){
    txt <- as.vector(as.character(base.msa))
    mat <- data.frame(rrb, txt)
    rown <- max(mat$row)
    coln <- max(mat$col)
    msa <- matrix(mat$residue_score, nrow = rown, ncol = coln)

    if (mask.cutoff=="auto"){ mask.cutoff <- 0.50 }

    if (inherits(sequences, "DNAbin")){
      msa[msa<mask.cutoff & !is.na(msa)] <- "N"
      mask.msa <- as.DNAbin(msa)
      rownames(mask.msa) <- labels(sequences)
    }
    if (inherits(sequences, "AAbin")) {
      msa[msa<mask.cutoff & !is.na(msa)] <- "X"
      rownames(msa) <- labels(sequences)
      class(msa) <- "AAbin"
    }
    HoT.msa <- msa
  }
  ## remove unreliable columns
  if (col.cutoff>0){
    ifelse(mask.cutoff>0, msa <- HoT.msa, msa <- base.msa)
    if(col.cutoff =="auto"){col.cutoff <- 0.97}
    remove_cols <- crb[,2] < col.cutoff
    HoT.msa <- msa[,!remove_cols]
  }
  ## remove unreliable sequences
  if (seq.cutoff>0){
    ifelse(mask.cutoff>0, msa <- HoT.msa, msa <- base.msa)
    if (seq.cutoff =="auto"){seq.cutoff <- 0.5}
    remove_seq <- srb$sequencesuence_score < seq.cutoff
    HoT.msa <- HoT.msa[!remove_seq,]
  }


  res <-  list(alignment_reliability = alignment_reliability,
    residue_reliability = rrb,
    column_reliability = crb,
    sequence_reliability = srb,
    HoT_MSA = HoT.msa,
    base_msa = base.msa)

  return(res)
}
